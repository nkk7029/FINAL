<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Steganography and Cryptography Assignment</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; max-width: 800px; margin: auto; }
    h1 { text-align: center; }
    section { border: 1px solid #ddd; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; }
    label, input, select, button, a { display: block; width: 100%; margin: .5rem 0; }
    button, a { cursor: pointer; text-align: center; padding: .5rem; background: #0288d1; color: white; border: none; border-radius: 4px; text-decoration: none; }
    a { background: none; color: #0288d1; padding: 0; margin: .5rem 0; }
  </style>
</head>
<body>
  <h1>Steganography and Cryptography Assignment</h1>

  <!-- LSB Steganography -->
  <section id="stego">
    <h2>LSB Steganography</h2>
    <label>Carrier Image:</label>
    <input type="file" id="carrierInput" accept="image/*" />
    <label>Secret Message:</label>
    <input type="text" id="secretMsg" placeholder="Enter your secret" />
    <button id="encodeBtn">Encode & Download</button>
    <a id="downloadLink" style="display:none;"></a>
    <hr/>
    <label>Stego Image:</label>
    <input type="file" id="stegoInput" accept="image/*" />
    <button id="decodeBtn">Decode Secret</button>
    <p id="decoded"></p>
  </section>

  <!-- Symmetric Encryption -->
  <section id="symmetric">
    <h2>Symmetric Encryption (AES / 3DES)</h2>
    <label>Algorithm:</label>
    <select id="symAlgo">
      <option value="AES">AES</option>
      <option value="3DES">3DES</option>
    </select>
    <label>Passphrase:</label>
    <input type="password" id="symKey" placeholder="Password / Passphrase" />
    <label>File to Encrypt:</label>
    <input type="file" id="symFile" />
    <button id="encryptSym">Encrypt File</button>
    <a id="symDownloadLink" style="display:none;"></a>
    <hr/>
    <label>Encrypted File:</label>
    <input type="file" id="symEncryptedFile" />
    <button id="decryptSym">Decrypt File</button>
    <a id="symDecryptLink" style="display:none;"></a>
  </section>

  <!-- Hashing -->
  <section id="hashing">
    <h2>Hashing (SHA-256 / SHA-3)</n    </h2>
    <label>Algorithm:</label>
    <select id="hashAlgo">
      <option value="SHA256">SHA-256</option>
      <option value="SHA3">SHA-3</option>
    </select>
    <label>File to Hash:</label>
    <input type="file" id="hashFile" />
    <button id="doHash">Compute Hash</button>
    <label>Hash Output (hex):</label>
    <textarea id="hashOutput" readonly></textarea>
  </section>

  <!-- RSA Asymmetric -->
  <section id="rsa">
    <h2>Asymmetric RSA (2048-bit)</h2>
    <button id="genRSA">Generate Keypair</button>
    <label>Public Key (PEM):</label>
    <textarea id="publicKey" readonly></textarea>
    <label>Private Key (PEM):</label>
    <textarea id="privateKey" readonly></textarea>
    <label>File to Encrypt:</label>
    <input type="file" id="rsaFile" />
    <button id="encryptRSA">Encrypt File</button>
    <a id="rsaDownloadLink" style="display:none;"></a>
    <hr/>
    <label>Encrypted File:</label>
    <input type="file" id="rsaEncryptedFile" />
    <button id="decryptRSA">Decrypt File</button>
    <a id="rsaDecryptLink" style="display:none;"></a>
  </section>

  <!-- CDN scripts -->
  <script src="https://unpkg.com/steganography.js@1.1.0/dist/steganography.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://unpkg.com/openpgp@5.7.0/dist/openpgp.min.js"></script>
  <script>
    // Helper to download Blob
    function downloadBlob(blob, filename, linkId) {
      const url = URL.createObjectURL(blob);
      const link = document.getElementById(linkId);
      link.href = url;
      link.download = filename;
      link.textContent = `⬇️ Download ${filename}`;
      link.style.display = 'block';
    }

    // — LSB Steganography —
    const steg = window.steganography || window.stegano || window.steg;
    document.getElementById('encodeBtn').onclick = () => {
      const file = document.getElementById('carrierInput').files[0];
      const msg  = document.getElementById('secretMsg').value;
      if (!file || !msg) return alert('Select an image and enter a message');
      const fr = new FileReader();
      fr.onload = () => {
        const dataURL = steg.encode(msg, fr.result);
        const [header, base64] = dataURL.split(',');
        const mime = header.match(/:(.*?);/)[1];
        const raw = atob(base64);
        const arr = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
        const blob = new Blob([arr], { type: mime });
        downloadBlob(blob, 'stego.png', 'downloadLink');
      };
      fr.readAsDataURL(file);
    };
    document.getElementById('decodeBtn').onclick = () => {
      const file = document.getElementById('stegoInput').files[0];
      if (!file) return alert('Select a stego image');
      const fr = new FileReader();
      fr.onload = () => {
        const hidden = steg.decode(fr.result);
        document.getElementById('decoded').textContent = hidden || '(no message found)';
      };
      fr.readAsDataURL(file);
    };

    // — Symmetric Encryption —
    document.getElementById('encryptSym').onclick = () => {
      const algo = document.getElementById('symAlgo').value;
      const key  = document.getElementById('symKey').value;
      const file = document.getElementById('symFile').files[0];
      if (!file || !key) return alert('Select file and enter passphrase');
      const fr = new FileReader();
      fr.onload = () => {
        const wordArr = CryptoJS.lib.WordArray.create(fr.result);
        const fn = algo === 'AES' ? CryptoJS.AES.encrypt : CryptoJS.TripleDES.encrypt;
        const ct = fn(wordArr, key).toString();
        const blob = new Blob([ct], { type: 'application/octet-stream' });
        downloadBlob(blob, 'sym_encrypted.txt', 'symDownloadLink');
      };
      fr.readAsArrayBuffer(file);
    };
    document.getElementById('decryptSym').onclick = () => {
      const algo = document.getElementById('symAlgo').value;
      const key  = document.getElementById('symKey').value;
      const file = document.getElementById('symEncryptedFile').files[0];
      if (!file || !key) return alert('Select encrypted file and passphrase');
      const fr = new FileReader();
      fr.onload = () => {
        const ct = new TextDecoder().decode(fr.result);
        const fn = algo === 'AES' ? CryptoJS.AES.decrypt : CryptoJS.TripleDES.decrypt;
        const pt = fn(ct, key).toString(CryptoJS.enc.Utf8);
        const blob = new Blob([pt], { type: 'application/octet-stream' });
        downloadBlob(blob, 'sym_decrypted.txt', 'symDecryptLink');
      };
      fr.readAsArrayBuffer(file);
    };

    // — Hashing —
    document.getElementById('doHash').onclick = () => {
      const algo = document.getElementById('hashAlgo').value;
      const file = document.getElementById('hashFile').files[0];
      if (!file) return alert('Select a file to hash');
      const fr = new FileReader();
      fr.onload = () => {
        const wordArr = CryptoJS.lib.WordArray.create(fr.result);
        const fn = algo === 'SHA256' ? CryptoJS.SHA256 : CryptoJS.SHA3;
        document.getElementById('hashOutput').value = fn(wordArr).toString();
      };
      fr.readAsArrayBuffer(file);
    };

    // — RSA Asymmetric —
    let rsaPriv, rsaPub;
    document.getElementById('genRSA').onclick = async () => {
      const key = await openpgp.generateKey({ type: 'rsa', rsaBits: 2048, userIDs: [{ name: 'User', email: '' }] });
      rsaPriv = key.privateKey; rsaPub = key.publicKey;
      document.getElementById('publicKey').value  = rsaPub;
      document.getElementById('privateKey').value = rsaPriv;
    };
    document.getElementById('encryptRSA').onclick = async () => {
      const file = document.getElementById('rsaFile').files[0];
      if (!file || !rsaPub) return alert('Select file and generate keypair first');
      const fr = new FileReader();
      fr.onload = async () => {
        const message = await openpgp.createMessage({ binary: new Uint8Array(fr.result) });
        const encrypted = await openpgp.encrypt({ message, encryptionKeys: await openpgp.readKey({ armoredKey: rsaPub }) });
        const blob = new Blob([encrypted], { type: 'application/octet-stream' });
        downloadBlob(blob, 'rsa_encrypted.asc', 'rsaDownloadLink');
      };
      fr.readAsArrayBuffer(file);
    };
    document.getElementById('decryptRSA').onclick = async () => {
      const file = document.getElementById('rsaEncryptedFile').files[0];
      if (!file || !rsaPriv) return alert('Select encrypted file and generate keypair first');
      const fr = new FileReader();
      fr.onload = async () => {
        const message = await openpgp.readMessage({ armoredMessage: new TextDecoder().decode(fr.result) });
        const { data: decrypted } = await openpgp.decrypt({ message, decryptionKeys: await openpgp.readPrivateKey({ armoredKey: rsaPriv }) });
        const blob = new Blob([decrypted], { type: 'application/octet-stream' });
        downloadBlob(blob, 'rsa_decrypted.bin', 'rsaDecryptLink');
      };
      fr.readAsArrayBuffer(file);
    };
  </script>
</body>
</html>
