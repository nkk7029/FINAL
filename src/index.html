<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Steganography and Cryptography Assignment</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; max-width: 800px; margin: auto; }
    h1 { text-align: center; }
    section { border: 1px solid #ddd; padding: 1rem; margin-bottom: 1rem; border-radius: 4px; }
    label, input, select, textarea, button, a { display: block; width: 100%; margin: .5rem 0; }
    button, a.button { cursor: pointer; background: #0288d1; color: white; border: none; padding: .5rem; text-decoration: none; text-align: center; border-radius: 4px; }
    a.download { background: none; color: #0288d1; padding: 0; margin: .5rem 0; }
  </style>
</head>
<body>
  <h1>Steganography and Cryptography Assignment</h1>

  <!-- LSB Steganography -->
  <section id="stego">
    <h2>LSB Steganography</h2>
    <p>Skip first <strong>100 bytes</strong> and embed every <strong>8th bit</strong> (L = 8).</p>
    <label>Carrier File:</label>
    <input type="file" id="carrierInput" />
    <label>Message File to Hide:</label>
    <input type="file" id="messageInput" />
    <button id="encodeBtn" class="button">Embed & Download Stego File</button>
    <a id="downloadLink" class="download" style="display:none"></a>
    <hr/>
    <button id="decodeBtn" class="button">Extract Hidden File from Stego</button>
  </section>

  <!-- Symmetric Encryption -->
  <section id="symmetric">
    <h2>Symmetric Encryption (AES / 3DES)</h2>
    <label>Algorithm:</label>
    <select id="symAlgo">
      <option value="AES">AES</option>
      <option value="3DES">3DES</option>
    </select>
    <label>Passphrase:</label>
    <input type="password" id="symKey" placeholder="Password / Passphrase" />
    <label>File to Encrypt:</label>
    <input type="file" id="symFile" />
    <button id="encryptSym" class="button">Encrypt File</button>
    <a id="symDownloadLink" class="download" style="display:none"></a>
    <hr/>
    <label>File to Decrypt:</label>
    <input type="file" id="symEncryptedFile" />
    <button id="decryptSym" class="button">Decrypt File</button>
    <a id="symDecryptLink" class="download" style="display:none"></a>
  </section>

  <!-- Hashing -->
  <section id="hashing">
    <h2>Hashing (SHA-256 / SHA-3)</h2>
    <label>Algorithm:</label>
    <select id="hashAlgo">
      <option value="SHA256">SHA-256</option>
      <option value="SHA3">SHA-3</option>
    </select>
    <label>File to Hash:</label>
    <input type="file" id="hashFile" />
    <button id="doHash" class="button">Compute Hash</button>
    <label>Hash Output (hex):</label>
    <textarea id="hashOutput" readonly></textarea>
  </section>

  <!-- Asymmetric RSA -->
  <section id="rsa">
    <h2>Asymmetric RSA (2048-bit)</h2>
    <button id="genRSA" class="button">Generate Keypair</button>
    <label>Public Key (PEM):</label>
    <textarea id="publicKey" readonly></textarea>
    <label>Private Key (PEM):</label>
    <textarea id="privateKey" readonly></textarea>
    <label>File to Encrypt:</label>
    <input type="file" id="rsaFile" />
    <button id="encryptRSA" class="button">Encrypt File</button>
    <a id="rsaDownloadLink" class="download" style="display:none"></a>
    <hr/>
    <label>Encrypted File to Decrypt:</label>
    <input type="file" id="rsaEncryptedFile" />
    <button id="decryptRSA" class="button">Decrypt File</button>
    <a id="rsaDecryptLink" class="download" style="display:none"></a>
  </section>

  <!-- Libraries -->
  <script src="https://unpkg.com/steganography.js@1.1.0/dist/steganography.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script src="https://unpkg.com/openpgp@5.7.0/dist/openpgp.min.js"></script>
  <script>
    const SKIP_BYTES = 100;
    const STEP_BITS  = 8;
    // Buffer <-> Bits
    function bufferToBits(buf) {
      const bytes = new Uint8Array(buf), bits = [];
      bytes.forEach(b => {
        for(let i=7;i>=0;i--) bits.push((b>>i)&1);
      });
      return bits;
    }
    function bitsToBuffer(bits) {
      const len = Math.floor(bits.length/8), bytes = new Uint8Array(len);
      for(let i=0;i<len;i++){
        let byte=0;
        for(let j=0;j<8;j++) byte = (byte<<1)|bits[i*8+j];
        bytes[i]=byte;
      }
      return bytes.buffer;
    }
    function embedBuffers(carrierBuf, messageBuf) {
      const cBits = bufferToBits(carrierBuf), mBits = bufferToBits(messageBuf);
      const skip = SKIP_BYTES*8;
      mBits.forEach((bit,i)=>{
        const pos = skip + i*STEP_BITS;
        if(pos<cBits.length) cBits[pos]=bit;
      });
      return bitsToBuffer(cBits);
    }
    function extractBuffer(stegoBuf) {
      const bits = bufferToBits(stegoBuf), skip=SKIP_BYTES*8, out=[];
      for(let pos=skip;pos<bits.length; pos+=STEP_BITS) out.push(bits[pos]);
      return bitsToBuffer(out);
    }
    function downloadBuffer(buf,name) {
      const blob=new Blob([buf],{type:'application/octet-stream'});
      const url=URL.createObjectURL(blob);
      const link=document.getElementById('downloadLink');
      link.href=url; link.download=name;
      link.textContent=`⬇️ Download ${name}`;
      link.style.display='block';
    }
    // Stego events
    document.getElementById('encodeBtn').onclick=()=>{
      const c=document.getElementById('carrierInput').files[0], m=document.getElementById('messageInput').files[0];
      if(!c||!m)return alert('Select both files');
      const frC=new FileReader();
      frC.onload=()=>{
        const carrierBuf=frC.result;
        const frM=new FileReader();
        frM.onload=()=>{
          const msgBuf=frM.result;
          const stegoBuf=embedBuffers(carrierBuf,msgBuf);
          downloadBuffer(stegoBuf,'stego.bin');
        };
        frM.readAsArrayBuffer(m);
      };
      frC.readAsArrayBuffer(c);
    };
    document.getElementById('decodeBtn').onclick=()=>{
      const c=document.getElementById('carrierInput').files[0];
      if(!c)return alert('Upload stego as carrier');
      const fr=new FileReader();
      fr.onload=()=>{ const buf=extractBuffer(fr.result); downloadBuffer(buf,'extracted.bin'); };
      fr.readAsArrayBuffer(c);
    };
    // Symmetric events
    function downloadSym(blob,name,id){
      const url=URL.createObjectURL(blob);
      const link=document.getElementById(id);
      link.href=url; link.download=name;
      link.textContent=`⬇️ Download ${name}`; link.style.display='block';
    }
    document.getElementById('encryptSym').onclick=()=>{
      const algo=document.getElementById('symAlgo').value, key=document.getElementById('symKey').value;
      const f=document.getElementById('symFile').files[0]; if(!f||!key)return alert('Select file & key');
      const fr=new FileReader(); fr.onload=()=>{
        const wa=CryptoJS.lib.WordArray.create(fr.result);
        const fn=algo==='AES'?CryptoJS.AES.encrypt:CryptoJS.TripleDES.encrypt;
        const ct=fn(wa,key).toString();
        downloadSym(new Blob([ct],{type:'application/octet-stream'}),'sym_encrypted.txt','symDownloadLink');
      }; fr.readAsArrayBuffer(f);
    };
    document.getElementById('decryptSym').onclick=()=>{
      const algo=document.getElementById('symAlgo').value, key=document.getElementById('symKey').value;
      const f=document.getElementById('symEncryptedFile').files[0]; if(!f||!key)return alert('Select encrypted & key');
      const fr=new FileReader(); fr.onload=()=>{
        const ct=new TextDecoder().decode(fr.result);
        const fn=algo==='AES'?CryptoJS.AES.decrypt:CryptoJS.TripleDES.decrypt;
        const pt=fn(ct,key).toString(CryptoJS.enc.Utf8);
        downloadSym(new Blob([pt],{type:'application/octet-stream'}),'sym_decrypted.txt','symDecryptLink');
      }; fr.readAsArrayBuffer(f);
    };
    // Hash events
    document.getElementById('doHash').onclick=()=>{
      const algo=document.getElementById('hashAlgo').value;
      const f=document.getElementById('hashFile').files[0]; if(!f)return alert('Select file');
      const fr=new FileReader(); fr.onload=()=>{
        const wa=CryptoJS.lib.WordArray.create(fr.result);
        const fn=algo==='SHA256'?CryptoJS.SHA256:CryptoJS.SHA3;
        document.getElementById('hashOutput').value=fn(wa).toString();
      }; fr.readAsArrayBuffer(f);
    };
    // RSA events
    let rsaPriv,rsaPub;
    document.getElementById('genRSA').onclick=async()=>{
      const key=await openpgp.generateKey({type:'rsa',rsaBits:2048,userIDs:[{name:'User',email:''}]});
      rsaPriv=key.privateKey; rsaPub=key.publicKey;
      document.getElementById('publicKey').value=rsaPub;
      document.getElementById('privateKey').value=rsaPriv;
    };
    function downloadRSA(data,name,id){
      const blob=new Blob([data],{type:'application/octet-stream'});
      const url=URL.createObjectURL(blob);
      const link=document.getElementById(id);
      link.href=url; link.download=name;
      link.textContent=`⬇️ Download ${name}`; link.style.display='block';
    }
    document.getElementById('encryptRSA').onclick=async()=>{
      const f=document.getElementById('rsaFile').files[0]; if(!f||!rsaPub)return alert('Select file & generate keys');
      const fr=new FileReader(); fr.onload=async()=>{
        const msg=await openpgp.createMessage({binary:new Uint8Array(fr.result)});
        const encrypted=await openpgp.encrypt({message:msg,encryptionKeys:await openpgp.readKey({armoredKey:rsaPub})});
        downloadRSA(encrypted,'rsa_encrypted.asc','rsaDownloadLink');
      }; fr.readAsArrayBuffer(f);
    };
    document.getElementById('decryptRSA').onclick=async()=>{
      const f=document.getElementById('rsaEncryptedFile').files[0]; if(!f||!rsaPriv)return alert('Select encrypted & generate keys');
      const fr=new FileReader(); fr.onload=async()=>{
        const raw=new TextDecoder().decode(fr.result);
        const msg=await openpgp.readMessage({armoredMessage:raw});
        const {data:decrypted}=await openpgp.decrypt({message:msg,decryptionKeys:await openpgp.readPrivateKey({armoredKey:rsaPriv})});
        downloadRSA(decrypted,'rsa_decrypted.bin','rsaDecryptLink');
      }; fr.readAsArrayBuffer(f);
    };
  </script>
</body>
</html>
